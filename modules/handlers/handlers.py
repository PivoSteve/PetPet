from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from modules.libraries.database import get_pet, create_pet, update_pet
from datetime import datetime, timedelta
import random

router = Router()

class PetStates(StatesGroup):
    waiting_for_name = State()
    waiting_for_game_choice = State()
    waiting_for_riddle_answer = State()
    waiting_for_training_choice = State()
    waiting_for_training_intensity = State()

def parse_datetime(date_string):
    if not date_string:
        return datetime.min
    try:
        return datetime.fromisoformat(date_string)
    except (TypeError, ValueError):
        return datetime.min

def get_main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üîç –°—Ç–∞—Ç—É—Å"), KeyboardButton(text="üçΩ –ü–æ–∫–æ—Ä–º–∏—Ç—å")],
            [KeyboardButton(text="üöø –ü–æ–º—ã—Ç—å"), KeyboardButton(text="üéÆ –ü–æ–∏–≥—Ä–∞—Ç—å")],
            [KeyboardButton(text="üò¥ –£–ª–æ–∂–∏—Ç—å —Å–ø–∞—Ç—å")]
        ],
        resize_keyboard=True
    )

@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    pet = get_pet(message.from_user.id)
    if pet:
        await message.answer(f"–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –¢–≤–æ–π –ø–∏—Ç–æ–º–µ—Ü {pet['name']} –∂–¥–µ—Ç —Ç–µ–±—è!", reply_markup=get_main_keyboard())
    else:
        await message.answer("–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π —Å–æ–∑–¥–∞–¥–∏–º —Ç–≤–æ–µ–≥–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø–∏—Ç–æ–º—Ü–∞. –ö–∞–∫ —Ç—ã —Ö–æ—á–µ—à—å –µ–≥–æ –Ω–∞–∑–≤–∞—Ç—å?")
        await state.set_state(PetStates.waiting_for_name)

@router.message(PetStates.waiting_for_name)
async def create_new_pet(message: Message, state: FSMContext):
    create_pet(message.from_user.id, message.text)
    pet = get_pet(message.from_user.id)
    await message.answer(
        f"–û—Ç–ª–∏—á–Ω–æ! –¢–≤–æ–π –Ω–æ–≤—ã–π –ø–∏—Ç–æ–º–µ—Ü {message.text} —Å–æ–∑–¥–∞–Ω. –í–æ—Ç –µ–≥–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:\n"
        f"–•–∞—Ä–∞–∫—Ç–µ—Ä: {pet['personality']}\n"
        f"–õ—é–±–∏–º–∞—è –µ–¥–∞: {pet['favorite_food']}\n"
        f"–õ—é–±–∏–º–æ–µ –∑–∞–Ω—è—Ç–∏–µ: {pet['favorite_activity']}\n"
        f"–£—Ö–∞–∂–∏–≤–∞–π –∑–∞ –Ω–∏–º —Ö–æ—Ä–æ—à–æ!",
        reply_markup=get_main_keyboard()
    )
    await state.clear()

@router.message(F.text == "üîç –°—Ç–∞—Ç—É—Å")
async def cmd_status(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        status_emoji = {
            'hunger': 'üçî –ì–æ–ª–æ–¥',
            'cleanliness': 'üöø –ß–∏—Å—Ç–æ—Ç–∞',
            'happiness': 'üòä –°—á–∞—Å—Ç—å–µ',
            'energy': '‚ö° –≠–Ω–µ—Ä–≥–∏—è',
            'intelligence': 'üß† –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç',
        }
        status_text = f"–°—Ç–∞—Ç—É—Å {pet['name']}:\nüôÉ –•–∞—Ä–∞–∫—Ç–µ—Ä: {pet['personality']}\nü•ò –õ—é–±–∏–º–∞—è –µ–¥–∞: {pet['favorite_food']}\nüèÖ –õ—é–±–∏–º–æ–µ –∑–∞–Ω—è—Ç–∏–µ: {pet['favorite_activity']}\n"
        for stat, emoji in status_emoji.items():
            value = pet[stat]
            bars = '‚ñà' * (value // 10) + '‚ñí' * ((100 - value) // 10)
            status_text += f"{emoji}: {bars} {value}/100\n"
        await message.answer(status_text)
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.message(F.text == "üçΩ –ü–æ–∫–æ—Ä–º–∏—Ç—å")
async def cmd_feed(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_fed = parse_datetime(pet.get('last_fed'))
        if datetime.now() - last_fed > timedelta(minutes=15):
            foods = ["üçé –Ø–±–ª–æ–∫–æ", "ü•ï –ú–æ—Ä–∫–æ–≤—å", "üçå –ë–∞–Ω–∞–Ω", "ü•ú –û—Ä–µ—Ö–∏", "üçì –Ø–≥–æ–¥—ã"]
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=food, callback_data=f"feed_{food.split()[1]}") for food in foods[:3]],
                [InlineKeyboardButton(text=food, callback_data=f"feed_{food.split()[1]}") for food in foods[3:]]
            ])
            await message.answer("–ß–µ–º —Ç—ã —Ö–æ—á–µ—à—å –ø–æ–∫–æ—Ä–º–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞?", reply_markup=keyboard)
        else:
            await message.answer(f"{pet['name']} –Ω–µ –≥–æ–ª–æ–¥–µ–Ω. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∫–æ—Ä–º–ª–µ–Ω–∏–µ–º.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.callback_query(F.data.startswith("feed_"))
async def process_feed(callback_query: CallbackQuery):
    food = callback_query.data.split("_")[1]
    pet = get_pet(callback_query.from_user.id)
    new_hunger = max(0, pet['hunger'] - 30)
    new_energy = min(100, pet['energy'] + 20)
    happiness_boost = 15 if food == pet['favorite_food'] else 5
    new_happiness = min(100, pet['happiness'] + happiness_boost)
    update_pet(callback_query.from_user.id, hunger=new_hunger, energy=new_energy, happiness=new_happiness, last_fed=datetime.now().isoformat())
    
    response = f"–¢—ã –ø–æ–∫–æ—Ä–º–∏–ª {pet['name']} {food}. "
    if food == pet['favorite_food']:
        response += f"–≠—Ç–æ –µ–≥–æ –ª—é–±–∏–º–∞—è –µ–¥–∞! –û–Ω –æ—á–µ–Ω—å –¥–æ–≤–æ–ª–µ–Ω! "
    response += f"–£—Ä–æ–≤–µ–Ω—å –≥–æ–ª–æ–¥–∞ —Ç–µ–ø–µ—Ä—å {new_hunger}/100, —ç–Ω–µ—Ä–≥–∏–∏ {new_energy}/100, –∞ —Å—á–∞—Å—Ç—å—è {new_happiness}/100."
    
    await callback_query.message.edit_text(response)

@router.message(F.text == "üöø –ü–æ–º—ã—Ç—å")
async def cmd_clean(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_cleaned = parse_datetime(pet.get('last_cleaned'))
        if datetime.now() - last_cleaned > timedelta(minutes=25):
            new_cleanliness = min(100, pet['cleanliness'] + 40)
            new_happiness = min(100, pet['happiness'] + 10)
            update_pet(message.from_user.id, cleanliness=new_cleanliness, happiness=new_happiness, last_cleaned=datetime.now().isoformat())
            await message.answer(f"–¢—ã –ø–æ–º—ã–ª {pet['name']}. –£—Ä–æ–≤–µ–Ω—å —á–∏—Å—Ç–æ—Ç—ã —Ç–µ–ø–µ—Ä—å {new_cleanliness}/100, –∞ —Å—á–∞—Å—Ç—å—è {new_happiness}/100.")
        else:
            await message.answer(f"{pet['name']} —É–∂–µ —á–∏—Å—Ç—ã–π. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∫—É–ø–∞–Ω–∏–µ–º.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.message(F.text == "üéÆ –ü–æ–∏–≥—Ä–∞—Ç—å")
async def cmd_play(message: Message, state: FSMContext):
    pet = get_pet(message.from_user.id)
    if pet:
        last_played = parse_datetime(pet.get('last_played'))
        if datetime.now() - last_played > timedelta(minutes=10):
            games = ["üß© –ó–∞–≥–∞–¥–∫–∏", "üèÉ‚Äç‚ôÇÔ∏è –ü—Ä—è—Ç–∫–∏", "üñåÔ∏è –†–∏—Å–æ–≤–∞–Ω–∏–µ", "‚öΩ –ú—è—á", "üß† –ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∏"]
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=game, callback_data=f"play_{game.split()[1]}") for game in games[:2]],
                [InlineKeyboardButton(text=game, callback_data=f"play_{game.split()[1]}") for game in games[2:]]
            ])
            await message.answer("–í–æ —á—Ç–æ —Ç—ã —Ö–æ—á–µ—à—å –ø–æ–∏–≥—Ä–∞—Ç—å —Å –ø–∏—Ç–æ–º—Ü–µ–º?", reply_markup=keyboard)
            await state.set_state(PetStates.waiting_for_game_choice)
        else:
            await message.answer(f"{pet['name']} —É—Å—Ç–∞–ª. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –∏–≥—Ä–æ–π.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.callback_query(PetStates.waiting_for_game_choice)
async def process_game_choice(callback_query: CallbackQuery, state: FSMContext):
    game = callback_query.data.split("_")[1]
    pet = get_pet(callback_query.from_user.id)
    
    if game == "–ó–∞–≥–∞–¥–∫–∏":
        riddles = [
            ("–£ –Ω–µ–≥–æ –æ–≥—Ä–æ–º–Ω—ã–π —Ä–æ—Ç, –û–Ω –∑–æ–≤–µ—Ç—Å—è ‚Ä¶", "–±–µ–≥–µ–º–æ—Ç"),
            ("–ù–µ –ø—Ç–∏—Ü–∞, –∞ —Å –∫—Ä—ã–ª—å—è–º–∏, –ù–µ –ø—á–µ–ª–∞, –∞ –Ω–∞–¥ —Ü–≤–µ—Ç–∫–æ–º", "–±–∞–±–æ—á–∫–∞"),
            ("–ß—Ç–æ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º, –Ω–æ –¥—Ä—É–≥–∏–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç —ç—Ç–æ —á–∞—â–µ?", "–º–æ—ë –∏–º—è"),
            ("–ß—Ç–æ –º–æ–∂–Ω–æ –≤–∏–¥–µ—Ç—å —Å –∑–∞–∫—Ä—ã—Ç—ã–º–∏ –≥–ª–∞–∑–∞–º–∏?", "—Å–æ–Ω"),
            ("–ö–∞–∫ —á–µ–ª–æ–≤–µ–∫ –º–æ–∂–µ—Ç –ø—Ä–æ–≤–µ—Å—Ç–∏ 8 –¥–Ω–µ–π –±–µ–∑ —Å–Ω–∞?", "—Å–ø–∞—Ç—å –Ω–æ—á—å—é"),
            ("–ù–µ –∂–∏–≤–æ–µ, –∞ –Ω–∞ –≤—Å–µ—Ö —è–∑—ã–∫–∞—Ö –≥–æ–≤–æ—Ä–∏—Ç.", "—ç—Ö–æ"),
            ("–ß—Ç–æ –Ω–µ –≤–º–µ—Å—Ç–∏—Ç—Å—è –¥–∞–∂–µ –≤ —Å–∞–º—É—é –±–æ–ª—å—à—É—é –∫–∞—Å—Ç—Ä—é–ª—é?", "–µ—ë –∫—Ä—ã—à–∫–∞"),
            ("–ß–µ–º –∫–æ–Ω—á–∞–µ—Ç—Å—è –ª–µ—Ç–æ –∏ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –æ—Å–µ–Ω—å?", "–±—É–∫–≤–∞ –æ"),
            ("–í –≥–æ–¥—É 12 –º–µ—Å—è—Ü–µ–≤. –°–µ–º—å –∏–∑ –Ω–∏—Ö –∏–º–µ—é—Ç 31 –¥–µ–Ω—å. –°–∫–æ–ª—å–∫–æ –º–µ—Å—è—Ü–µ–≤ –≤ –≥–æ–¥—É –∏–º–µ—é—Ç 28 –¥–Ω–µ–π?", "–≤—Å–µ"),
            ("–ö—Ç–æ —Ö–æ–¥–∏—Ç —Å–∏–¥—è?", "—à–∞—Ö–º–∞—Ç–∏—Å—Ç—ã"),
            ("–•–≤–æ—Å—Ç –ø—É—à–∏—Å—Ç—ã–π, –º–µ—Ö –∑–æ–ª–æ—Ç–∏—Å—Ç—ã–π, –í –ª–µ—Å—É –∂–∏–≤–µ—Ç, –í –¥–µ—Ä–µ–≤–Ω–µ –∫—É—Ä –∫—Ä–∞–¥–µ—Ç", "–ª–∏—Å–∞")
        ]
        riddle, answer = random.choice(riddles)
        await state.update_data(correct_answer=answer)
        await callback_query.message.edit_text(f"–û—Ç–≥–∞–¥–∞–π –∑–∞–≥–∞–¥–∫—É:\n\n{riddle}")
        await state.set_state(PetStates.waiting_for_riddle_answer)
    else:
        happiness_boost = 25 if game == pet['favorite_activity'] else 15
        new_happiness = min(100, pet['happiness'] + happiness_boost)
        new_energy = max(0, pet['energy'] - 30)
        new_intelligence = min(100, pet['intelligence'] + 10)
        update_pet(callback_query.from_user.id, happiness=new_happiness, energy=new_energy, intelligence=new_intelligence, last_played=datetime.now().isoformat())
        
        response = f"–¢—ã –ø–æ–∏–≥—Ä–∞–ª —Å {pet['name']} –≤ {game}. "
        if game == pet['favorite_activity']:
            response += f"–≠—Ç–æ –µ–≥–æ –ª—é–±–∏–º–æ–µ –∑–∞–Ω—è—Ç–∏–µ! –û–Ω –≤ –≤–æ—Å—Ç–æ—Ä–≥–µ! "
        response += f"–£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, —ç–Ω–µ—Ä–≥–∏–∏ {new_energy}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100."
        
        await callback_query.message.edit_text(response)
        await state.clear()

@router.message(PetStates.waiting_for_riddle_answer)
async def process_riddle_answer(message: Message, state: FSMContext):
    data = await state.get_data()
    correct_answer = data.get("correct_answer")
    pet = get_pet(message.from_user.id)
    
    if message.text.lower() == correct_answer:
        new_happiness = min(100, pet['happiness'] + 30)
        new_intelligence = min(100, pet['intelligence'] + 20)
        update_pet(message.from_user.id, happiness=new_happiness, intelligence=new_intelligence, last_played=datetime.now().isoformat())
        await message.answer(f"–ü—Ä–∞–≤–∏–ª—å–Ω–æ! {pet['name']} –æ—á–µ–Ω—å —Ä–∞–¥, —á—Ç–æ –≤—ã —Ä–∞–∑–≥–∞–¥–∞–ª–∏ –∑–∞–≥–∞–¥–∫—É –≤–º–µ—Å—Ç–µ. –£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100.")
    else:
        new_happiness = min(100, pet['happiness'] + 10)
        new_intelligence = min(100, pet['intelligence'] + 5)
        update_pet(message.from_user.id, happiness=new_happiness, intelligence=new_intelligence, last_played=datetime.now().isoformat())
        await message.answer(f"–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {correct_answer}. –ù–æ {pet['name']} –≤—Å–µ —Ä–∞–≤–Ω–æ –¥–æ–≤–æ–ª–µ–Ω, —á—Ç–æ –≤—ã –∏–≥—Ä–∞–ª–∏ –≤–º–µ—Å—Ç–µ. –£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100.")
    
    await state.clear()

@router.message(F.text == "üò¥ –£–ª–æ–∂–∏—Ç—å —Å–ø–∞—Ç—å")
async def pet_sleep(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_slept = parse_datetime(pet.get('last_slept'))
        if datetime.now() - last_slept > timedelta(minutes=25) or pet.get('energy') < 40:
            sleep_duration = random.randint(4, 8)
            new_energy = min(100, pet['energy'] + sleep_duration * 10)
            new_hunger = min(100, pet['hunger'] + sleep_duration * 5)
            new_happiness = max(0, pet['happiness'] - sleep_duration * 2)
            new_cleanliness = max(0, pet['cleanliness'] - sleep_duration * 3)
            time_asleep = datetime.now() - timedelta(hours=sleep_duration)
            time_asleep_str = time_asleep.isoformat()
            
            update_pet(message.from_user.id, 
                       energy=new_energy, 
                       hunger=new_hunger, 
                       happiness=new_happiness, 
                       cleanliness=new_cleanliness, 
                       last_slept=datetime.now().isoformat(),
                       last_fed=time_asleep_str,
                       last_cleaned=time_asleep_str,
                       last_played=time_asleep_str)
            
            await message.answer(f"{pet['name']} –ø–æ—Å–ø–∞–ª {sleep_duration} —á–∞—Å–æ–≤ –∏ —Ö–æ—Ä–æ—à–æ –æ—Ç–¥–æ—Ö–Ω—É–ª! debug: {time_asleep_str}\n"
                                 f"–≠–Ω–µ—Ä–≥–∏—è: {new_energy}/100\n"
                                 f"–ì–æ–ª–æ–¥: {new_hunger}/100\n"
                                 f"–°—á–∞—Å—Ç—å–µ: {new_happiness}/100\n"
                                 f"–ß–∏—Å—Ç–æ—Ç–∞: {new_cleanliness}/100")
        else:
            await message.answer(f"{pet['name']} –µ—â–µ –Ω–µ —É—Å—Ç–∞–ª. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Å–Ω–æ–º.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")