from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from modules.libraries.database import get_pet, create_pet, update_pet
from datetime import datetime, timedelta
import random

router = Router()

class PetStates(StatesGroup):
    waiting_for_name = State()
    waiting_for_game_choice = State()
    waiting_for_riddle_answer = State()
    waiting_for_training_choice = State()

def get_main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üîç –°—Ç–∞—Ç—É—Å"), KeyboardButton(text="üçΩ –ü–æ–∫–æ—Ä–º–∏—Ç—å")],
            [KeyboardButton(text="üöø –ü–æ–º—ã—Ç—å"), KeyboardButton(text="üéÆ –ü–æ–∏–≥—Ä–∞—Ç—å")],
            [KeyboardButton(text="üò¥ –£–ª–æ–∂–∏—Ç—å —Å–ø–∞—Ç—å"), KeyboardButton(text="üí™ –¢—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å")]
        ],
        resize_keyboard=True
    )

@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    pet = get_pet(message.from_user.id)
    if pet:
        await message.answer(f"–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –¢–≤–æ–π –ø–∏—Ç–æ–º–µ—Ü {pet['name']} –∂–¥–µ—Ç —Ç–µ–±—è!", reply_markup=get_main_keyboard())
    else:
        await message.answer("–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π —Å–æ–∑–¥–∞–¥–∏–º —Ç–≤–æ–µ–≥–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø–∏—Ç–æ–º—Ü–∞. –ö–∞–∫ —Ç—ã —Ö–æ—á–µ—à—å –µ–≥–æ –Ω–∞–∑–≤–∞—Ç—å?")
        await state.set_state(PetStates.waiting_for_name)

@router.message(PetStates.waiting_for_name)
async def create_new_pet(message: Message, state: FSMContext):
    create_pet(message.from_user.id, message.text)
    pet = get_pet(message.from_user.id)
    await message.answer(
        f"–û—Ç–ª–∏—á–Ω–æ! –¢–≤–æ–π –Ω–æ–≤—ã–π –ø–∏—Ç–æ–º–µ—Ü {message.text} —Å–æ–∑–¥–∞–Ω. –í–æ—Ç –µ–≥–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:\n"
        f"–•–∞—Ä–∞–∫—Ç–µ—Ä: {pet['personality']}\n"
        f"–õ—é–±–∏–º–∞—è –µ–¥–∞: {pet['favorite_food']}\n"
        f"–õ—é–±–∏–º–æ–µ –∑–∞–Ω—è—Ç–∏–µ: {pet['favorite_activity']}\n"
        f"–£—Ö–∞–∂–∏–≤–∞–π –∑–∞ –Ω–∏–º —Ö–æ—Ä–æ—à–æ!",
        reply_markup=get_main_keyboard()
    )
    await state.clear()

@router.message(F.text == "üîç –°—Ç–∞—Ç—É—Å")
async def cmd_status(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        status_emoji = {
            'hunger': 'üçî',
            'cleanliness': 'üöø',
            'happiness': 'üòä',
            'energy': '‚ö°',
            'intelligence': 'üß†',
            'strength': 'üí™'
        }
        status_text = f"–°—Ç–∞—Ç—É—Å {pet['name']}:\n"
        for stat, emoji in status_emoji.items():
            value = pet[stat]
            bars = '‚ñà' * (value // 10) + '‚ñí' * ((100 - value) // 10)
            status_text += f"{emoji} {stat.capitalize()}: {bars} {value}/100\n"
        await message.answer(status_text)
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.message(F.text == "üçΩ –ü–æ–∫–æ—Ä–º–∏—Ç—å")
async def cmd_feed(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_fed = datetime.fromisoformat(pet['last_fed']) if pet['last_fed'] else datetime.min
        if datetime.now() - last_fed > timedelta(hours=1):
            foods = ["üçé –Ø–±–ª–æ–∫–æ", "ü•ï –ú–æ—Ä–∫–æ–≤—å", "üçå –ë–∞–Ω–∞–Ω", "ü•ú –û—Ä–µ—Ö–∏", "üçì –Ø–≥–æ–¥—ã"]
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=food, callback_data=f"feed_{food.split()[1]}") for food in foods[:3]],
                [InlineKeyboardButton(text=food, callback_data=f"feed_{food.split()[1]}") for food in foods[3:]]
            ])
            await message.answer("–ß–µ–º —Ç—ã —Ö–æ—á–µ—à—å –ø–æ–∫–æ—Ä–º–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞?", reply_markup=keyboard)
        else:
            await message.answer(f"{pet['name']} –Ω–µ –≥–æ–ª–æ–¥–µ–Ω. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∫–æ—Ä–º–ª–µ–Ω–∏–µ–º.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.callback_query(F.data.startswith("feed_"))
async def process_feed(callback_query: CallbackQuery):
    food = callback_query.data.split("_")[1]
    pet = get_pet(callback_query.from_user.id)
    new_hunger = max(0, pet['hunger'] - 30)
    new_energy = min(100, pet['energy'] + 20)
    happiness_boost = 15 if food == pet['favorite_food'] else 5
    new_happiness = min(100, pet['happiness'] + happiness_boost)
    update_pet(callback_query.from_user.id, hunger=new_hunger, energy=new_energy, happiness=new_happiness, last_fed=datetime.now().isoformat())
    
    response = f"–¢—ã –ø–æ–∫–æ—Ä–º–∏–ª {pet['name']} {food}. "
    if food == pet['favorite_food']:
        response += f"–≠—Ç–æ –µ–≥–æ –ª—é–±–∏–º–∞—è –µ–¥–∞! –û–Ω –æ—á–µ–Ω—å –¥–æ–≤–æ–ª–µ–Ω! "
    response += f"–£—Ä–æ–≤–µ–Ω—å –≥–æ–ª–æ–¥–∞ —Ç–µ–ø–µ—Ä—å {new_hunger}/100, —ç–Ω–µ—Ä–≥–∏–∏ {new_energy}/100, –∞ —Å—á–∞—Å—Ç—å—è {new_happiness}/100."
    
    await callback_query.message.edit_text(response)

@router.message(F.text == "üöø –ü–æ–º—ã—Ç—å")
async def cmd_clean(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_cleaned = datetime.fromisoformat(pet['last_cleaned']) if pet['last_cleaned'] else datetime.min
        if datetime.now() - last_cleaned > timedelta(hours=3):
            new_cleanliness = min(100, pet['cleanliness'] + 40)
            new_happiness = min(100, pet['happiness'] + 10)
            update_pet(message.from_user.id, cleanliness=new_cleanliness, happiness=new_happiness, last_cleaned=datetime.now().isoformat())
            await message.answer(f"–¢—ã –ø–æ–º—ã–ª {pet['name']}. –£—Ä–æ–≤–µ–Ω—å —á–∏—Å—Ç–æ—Ç—ã —Ç–µ–ø–µ—Ä—å {new_cleanliness}/100, –∞ —Å—á–∞—Å—Ç—å—è {new_happiness}/100.")
        else:
            await message.answer(f"{pet['name']} —É–∂–µ —á–∏—Å—Ç—ã–π. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∫—É–ø–∞–Ω–∏–µ–º.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.message(F.text == "üéÆ –ü–æ–∏–≥—Ä–∞—Ç—å")
async def cmd_play(message: Message, state: FSMContext):
    pet = get_pet(message.from_user.id)
    if pet:
        last_played = datetime.fromisoformat(pet['last_played']) if pet['last_played'] else datetime.min
        if datetime.now() - last_played > timedelta(hours=2):
            games = ["üß© –ó–∞–≥–∞–¥–∫–∏", "üèÉ‚Äç‚ôÇÔ∏è –ü—Ä—è—Ç–∫–∏", "‚öΩ –ú—è—á", "üß† –ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∏"]
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=game, callback_data=f"play_{game.split()[1]}") for game in games[:2]],
                [InlineKeyboardButton(text=game, callback_data=f"play_{game.split()[1]}") for game in games[2:]]
            ])
            await message.answer("–í–æ —á—Ç–æ —Ç—ã —Ö–æ—á–µ—à—å –ø–æ–∏–≥—Ä–∞—Ç—å —Å –ø–∏—Ç–æ–º—Ü–µ–º?", reply_markup=keyboard)
            await state.set_state(PetStates.waiting_for_game_choice)
        else:
            await message.answer(f"{pet['name']} —É—Å—Ç–∞–ª. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –∏–≥—Ä–æ–π.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.callback_query(PetStates.waiting_for_game_choice)
async def process_game_choice(callback_query: CallbackQuery, state: FSMContext):
    game = callback_query.data.split("_")[1]
    pet = get_pet(callback_query.from_user.id)
    
    if game == "–ó–∞–≥–∞–¥–∫–∏":
        riddles = [
            ("–£ –Ω–µ–≥–æ –æ–≥—Ä–æ–º–Ω—ã–π —Ä–æ—Ç, –û–Ω –∑–æ–≤–µ—Ç—Å—è ‚Ä¶", "–±–µ–≥–µ–º–æ—Ç"),
            ("–ù–µ –ø—Ç–∏—Ü–∞, –∞ —Å –∫—Ä—ã–ª—å—è–º–∏, –ù–µ –ø—á–µ–ª–∞, –∞ –Ω–∞–¥ —Ü–≤–µ—Ç–∫–æ–º", "–±–∞–±–æ—á–∫–∞"),
            ("–•–≤–æ—Å—Ç –ø—É—à–∏—Å—Ç—ã–π, –º–µ—Ö –∑–æ–ª–æ—Ç–∏—Å—Ç—ã–π, –í –ª–µ—Å—É –∂–∏–≤–µ—Ç, –í –¥–µ—Ä–µ–≤–Ω–µ –∫—É—Ä –∫—Ä–∞–¥–µ—Ç", "–ª–∏—Å–∞")
        ]
        riddle, answer = random.choice(riddles)
        await state.update_data(correct_answer=answer)
        await callback_query.message.edit_text(f"–û—Ç–≥–∞–¥–∞–π –∑–∞–≥–∞–¥–∫—É:\n\n{riddle}")
        await state.set_state(PetStates.waiting_for_riddle_answer)
    else:
        happiness_boost = 25 if game == pet['favorite_activity'] else 15
        new_happiness = min(100, pet['happiness'] + happiness_boost)
        new_energy = max(0, pet['energy'] - 30)
        new_intelligence = min(100, pet['intelligence'] + 10)
        update_pet(callback_query.from_user.id, happiness=new_happiness, energy=new_energy, intelligence=new_intelligence, last_played=datetime.now().isoformat())
        
        response = f"–¢—ã –ø–æ–∏–≥—Ä–∞–ª —Å {pet['name']} –≤ {game}. "
        if game == pet['favorite_activity']:
            response += f"–≠—Ç–æ –µ–≥–æ –ª—é–±–∏–º–æ–µ –∑–∞–Ω—è—Ç–∏–µ! –û–Ω –≤ –≤–æ—Å—Ç–æ—Ä–≥–µ! "
        response += f"–£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, —ç–Ω–µ—Ä–≥–∏–∏ {new_energy}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100."
        
        await callback_query.message.edit_text(response)
        await state.clear()

@router.message(PetStates.waiting_for_riddle_answer)
async def process_riddle_answer(message: Message, state: FSMContext):
    data = await state.get_data()
    correct_answer = data.get("correct_answer")
    pet = get_pet(message.from_user.id)
    
    if message.text.lower() == correct_answer:
        new_happiness = min(100, pet['happiness'] + 30)
        new_intelligence = min(100, pet['intelligence'] + 20)
        update_pet(message.from_user.id, happiness=new_happiness, intelligence=new_intelligence, last_played=datetime.now().isoformat())
        await message.answer(f"–ü—Ä–∞–≤–∏–ª—å–Ω–æ! {pet['name']} –æ—á–µ–Ω—å —Ä–∞–¥, —á—Ç–æ –≤—ã —Ä–∞–∑–≥–∞–¥–∞–ª–∏ –∑–∞–≥–∞–¥–∫—É –≤–º–µ—Å—Ç–µ. –£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100.")
    else:
        new_happiness = min(100, pet['happiness'] + 10)
        new_intelligence = min(100, pet['intelligence'] + 5)
        update_pet(message.from_user.id, happiness=new_happiness, intelligence=new_intelligence, last_played=datetime.now().isoformat())
        await message.answer(f"–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {correct_answer}. –ù–æ {pet['name']} –≤—Å–µ —Ä–∞–≤–Ω–æ –¥–æ–≤–æ–ª–µ–Ω, —á—Ç–æ –≤—ã –∏–≥—Ä–∞–ª–∏ –≤–º–µ—Å—Ç–µ. –£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100.")
    
    await state.clear()

@router.message(F.text == "üò¥ –£–ª–æ–∂–∏—Ç—å —Å–ø–∞—Ç—å")
async def pet_sleep(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_slept = datetime.fromisoformat(pet['last_slept']) if 'last_slept' in pet else datetime.min
        if datetime.now() - last_slept > timedelta(hours=6):
            sleep_duration = random.randint(4, 8)
            new_energy = min(100, pet['energy'] + sleep_duration * 10)
            new_hunger = min(100, pet['hunger'] + sleep_duration * 5)
            new_happiness = max(0, pet['happiness'] - sleep_duration * 2)
            new_cleanliness = max(0, pet['cleanliness'] - sleep_duration * 3)
            
            update_pet(message.from_user.id, 
                       energy=new_energy, 
                       hunger=new_hunger, 
                       happiness=new_happiness, 
                       cleanliness=new_cleanliness, 
                       last_slept=datetime.now().isoformat())
            
            await message.answer(f"{pet['name']} –ø–æ—Å–ø–∞–ª {sleep_duration} —á–∞—Å–æ–≤ –∏ —Ö–æ—Ä–æ—à–æ –æ—Ç–¥–æ—Ö–Ω—É–ª!\n"
                                 f"–≠–Ω–µ—Ä–≥–∏—è: {new_energy}/100\n"
                                 f"–ì–æ–ª–æ–¥: {new_hunger}/100\n"
                                 f"–°—á–∞—Å—Ç—å–µ: {new_happiness}/100\n"
                                 f"–ß–∏—Å—Ç–æ—Ç–∞: {new_cleanliness}/100")
        else:
            await message.answer(f"{pet['name']} –µ—â–µ –Ω–µ —É—Å—Ç–∞–ª. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Å–Ω–æ–º.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.message(F.text == "üí™ –¢—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å")
async def train_pet(message: Message, state: FSMContext):
    pet = get_pet(message.from_user.id)
    if pet:
        last_trained = datetime.fromisoformat(pet['last_trained']) if 'last_trained' in pet else datetime.min
        if datetime.now() - last_trained > timedelta(hours=4):
            activities = ["üèÉ‚Äç‚ôÇÔ∏è –ë–µ–≥", "üèä‚Äç‚ôÇÔ∏è –ü–ª–∞–≤–∞–Ω–∏–µ", "ü¶ò –ü—Ä—ã–∂–∫–∏", "üèãÔ∏è‚Äç‚ôÇÔ∏è –°–∏–ª–æ–≤—ã–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è"]
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=activity, callback_data=f"train_{activity.split()[1]}") for activity in activities[:2]],
                [InlineKeyboardButton(text=activity, callback_data=f"train_{activity.split()[1]}") for activity in activities[2:]]
            ])
            await message.answer("–ö–∞–∫—É—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É —Ç—ã —Ö–æ—á–µ—à—å –≤—ã–±—Ä–∞—Ç—å –¥–ª—è –ø–∏—Ç–æ–º—Ü–∞?", reply_markup=keyboard)
            await state.set_state(PetStates.waiting_for_training_choice)
        else:
            await message.answer(f"{pet['name']} –µ—â–µ –Ω–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è –ø–æ—Å–ª–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ.")
    else:
        await message.answer("–£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.callback_query(PetStates.waiting_for_training_choice)
async def process_training_choice(callback_query: CallbackQuery, state: FSMContext):
    training = callback_query.data.split("_")[1]
    pet = get_pet(callback_query.from_user.id)
    
    strength_boost = random.randint(10, 20)
    energy_loss = random.randint(20, 30)
    happiness_change = random.randint(-5, 10)
    
    new_strength = min(100, pet['strength'] + strength_boost)
    new_energy = max(0, pet['energy'] - energy_loss)
    new_happiness = max(0, min(100, pet['happiness'] + happiness_change))
    
    update_pet(callback_query.from_user.id, 
               strength=new_strength, 
               energy=new_energy, 
               happiness=new_happiness, 
               last_trained=datetime.now().isoformat())
    
    response = f"{pet['name']} –ø–æ—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞–ª—Å—è, –≤—ã–ø–æ–ª–Ω—è—è {training}.\n"
    response += f"–°–∏–ª–∞: {new_strength}/100 (+{strength_boost})\n"
    response += f"–≠–Ω–µ—Ä–≥–∏—è: {new_energy}/100 (-{energy_loss})\n"
    response += f"–°—á–∞—Å—Ç—å–µ: {new_happiness}/100 ({'+' if happiness_change > 0 else ''}{happiness_change})"
    
    await callback_query.message.edit_text(response)
    await state.clear()