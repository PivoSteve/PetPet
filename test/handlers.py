from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from modules.libraries.database import get_pet, create_pet, update_pet
from datetime import datetime, timedelta
import random

router = Router()

class PetStates(StatesGroup):
    waiting_for_name = State()
    waiting_for_game_choice = State()
    waiting_for_riddle_answer = State()
    waiting_for_math_answer = State()
    waiting_for_word_guess = State()

def parse_datetime(date_string):
    if not date_string:
        return datetime.min
    try:
        return datetime.fromisoformat(date_string)
    except (TypeError, ValueError):
        return datetime.min

def get_main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üîç –°—Ç–∞—Ç—É—Å"), KeyboardButton(text="üçΩ –ü–æ–∫–æ—Ä–º–∏—Ç—å")],
            [KeyboardButton(text="üöø –ü–æ–º—ã—Ç—å"), KeyboardButton(text="üéÆ –ü–æ–∏–≥—Ä–∞—Ç—å")],
            [KeyboardButton(text="üò¥ –£–ª–æ–∂–∏—Ç—å —Å–ø–∞—Ç—å")]
        ],
        resize_keyboard=True
    )

@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    pet = get_pet(message.from_user.id)
    if pet:
        await message.answer(f"‚úî –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –¢–≤–æ–π –ø–∏—Ç–æ–º–µ—Ü {pet['name']} –∂–¥–µ—Ç —Ç–µ–±—è!", reply_markup=get_main_keyboard())
    else:
        await message.answer("‚úî –ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π —Å–æ–∑–¥–∞–¥–∏–º —Ç–≤–æ–µ–≥–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø–∏—Ç–æ–º—Ü–∞. –ö–∞–∫ —Ç—ã —Ö–æ—á–µ—à—å –µ–≥–æ –Ω–∞–∑–≤–∞—Ç—å?")
        await state.set_state(PetStates.waiting_for_name)

@router.message(PetStates.waiting_for_name)
async def create_new_pet(message: Message, state: FSMContext):
    create_pet(message.from_user.id, message.text)
    pet = get_pet(message.from_user.id)
    await cmd_status(message, f"‚úî –û—Ç–ª–∏—á–Ω–æ! –¢–≤–æ–π –Ω–æ–≤—ã–π –ø–∏—Ç–æ–º–µ—Ü {pet['name']} —Å–æ–∑–¥–∞–Ω.\n–£—Ö–∞–∂–∏–≤–∞–π –∑–∞ –Ω–∏–º —Ö–æ—Ä–æ—à–æ! –í–æ—Ç –µ–≥–æ –Ω–∞—á–∞–ª—å–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:")
    await state.clear()

@router.message(F.text == "üîç –°—Ç–∞—Ç—É—Å")
async def cmd_status(message: Message, status_text: str):
    pet = get_pet(message.from_user.id)
    if pet:
        status_emoji = {
            'hunger': 'üçî –ì–æ–ª–æ–¥',
            'cleanliness': 'üöø –ß–∏—Å—Ç–æ—Ç–∞',
            'happiness': 'üòä –°—á–∞—Å—Ç—å–µ',
            'energy': '‚ö° –≠–Ω–µ—Ä–≥–∏—è',
            'intelligence': 'üß† –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç',
        }
        status_text += f"üôÉ –•–∞—Ä–∞–∫—Ç–µ—Ä: {pet['personality']}\nü•ò –õ—é–±–∏–º–∞—è –µ–¥–∞: {pet['favorite_food']}\nüèÖ –õ—é–±–∏–º–æ–µ –∑–∞–Ω—è—Ç–∏–µ: {pet['favorite_activity']}\n"
        for stat, emoji in status_emoji.items():
            value = pet[stat]
            bars = '‚ñà' * (value // 10) + '‚ñí' * ((100 - value) // 10)
            status_text += f"{emoji}: {bars} {value}/100\n"
        await message.answer(status_text)
    else:
        await message.answer("‚ùå –£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.message(F.text == "üçΩ –ü–æ–∫–æ—Ä–º–∏—Ç—å")
async def cmd_feed(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_fed = parse_datetime(pet.get('last_fed'))
        if datetime.now() - last_fed > timedelta(minutes=15):
            foods = ["üçé –Ø–±–ª–æ–∫–æ", "ü•ï –ú–æ—Ä–∫–æ–≤—å", "üçå –ë–∞–Ω–∞–Ω", "ü•ú –û—Ä–µ—Ö–∏", "üçì –Ø–≥–æ–¥—ã"]
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text=food, callback_data=f"feed_{food.split()[1]}") for food in foods[:3]],
                [InlineKeyboardButton(text=food, callback_data=f"feed_{food.split()[1]}") for food in foods[3:]]
            ])
            await message.answer("‚úî –ß–µ–º —Ç—ã —Ö–æ—á–µ—à—å –ø–æ–∫–æ—Ä–º–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞?", reply_markup=keyboard)
        else:
            await message.answer(f"‚ùå {pet['name']} –Ω–µ –≥–æ–ª–æ–¥–µ–Ω. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∫–æ—Ä–º–ª–µ–Ω–∏–µ–º.")
    else:
        await message.answer("‚ùå –£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.callback_query(F.data.startswith("feed_"))
async def process_feed(callback_query: CallbackQuery):
    food = callback_query.data.split("_")[1]
    pet = get_pet(callback_query.from_user.id)
    new_hunger = max(0, pet['hunger'] - 30)
    new_energy = min(100, pet['energy'] + 20)
    happiness_boost = 15 if food == pet['favorite_food'] else 5
    new_happiness = min(100, pet['happiness'] + happiness_boost)
    update_pet(callback_query.from_user.id, hunger=new_hunger, energy=new_energy, happiness=new_happiness, last_fed=datetime.now().isoformat())
    
    response = f"–¢—ã –ø–æ–∫–æ—Ä–º–∏–ª {pet['name']} {food}. "
    if food == pet['favorite_food']:
        response += f"‚úî –≠—Ç–æ –µ–≥–æ –ª—é–±–∏–º–∞—è –µ–¥–∞! –û–Ω –æ—á–µ–Ω—å –¥–æ–≤–æ–ª–µ–Ω! "
    response += f"‚úî –£—Ä–æ–≤–µ–Ω—å –≥–æ–ª–æ–¥–∞ —Ç–µ–ø–µ—Ä—å {new_hunger}/100, —ç–Ω–µ—Ä–≥–∏–∏ {new_energy}/100, –∞ —Å—á–∞—Å—Ç—å—è {new_happiness}/100."
    
    await callback_query.message.edit_text(response)

@router.message(F.text == "üöø –ü–æ–º—ã—Ç—å")
async def cmd_clean(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_cleaned = parse_datetime(pet.get('last_cleaned'))
        if datetime.now() - last_cleaned > timedelta(minutes=25):
            new_cleanliness = min(100, pet['cleanliness'] + 40)
            new_happiness = min(100, pet['happiness'] + 10)
            update_pet(message.from_user.id, cleanliness=new_cleanliness, happiness=new_happiness, last_cleaned=datetime.now().isoformat())
            await message.answer(f"‚úî –¢—ã –ø–æ–º—ã–ª {pet['name']}. –£—Ä–æ–≤–µ–Ω—å —á–∏—Å—Ç–æ—Ç—ã —Ç–µ–ø–µ—Ä—å {new_cleanliness}/100, –∞ —Å—á–∞—Å—Ç—å—è {new_happiness}/100.")
        else:
            await message.answer(f"‚ùå {pet['name']} —É–∂–µ —á–∏—Å—Ç—ã–π. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∫—É–ø–∞–Ω–∏–µ–º.")
    else:
        await message.answer("‚ùå –£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")

@router.message(F.text == "üéÆ –ü–æ–∏–≥—Ä–∞—Ç—å")
async def cmd_play(message: Message, state: FSMContext):
    pet = get_pet(message.from_user.id)
    if pet and can_play(pet):
        games = ["üß© –ó–∞–≥–∞–¥–∫–∏", "üî¢ –ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞", "üî§ –£–≥–∞–¥–∞–π —Å–ª–æ–≤–æ"]
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=game, callback_data=f"play_{game.split()[1]}") for game in games[:3]],
            [InlineKeyboardButton(text=game, callback_data=f"play_{game.split()[1]}") for game in games[3:]]
        ])
        await message.answer("‚úî –í–æ —á—Ç–æ —Ç—ã —Ö–æ—á–µ—à—å –ø–æ–∏–≥—Ä–∞—Ç—å —Å –ø–∏—Ç–æ–º—Ü–µ–º?", reply_markup=keyboard)
        await state.set_state(PetStates.waiting_for_game_choice)
    else:
        await message.answer(f"‚ùå {pet['name']} —É—Å—Ç–∞–ª. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –∏–≥—Ä–æ–π.")

@router.callback_query(PetStates.waiting_for_game_choice)
async def process_game_choice(callback_query: CallbackQuery, state: FSMContext):
    game = callback_query.data.split("_")[1]
    pet = get_pet(callback_query.from_user.id)
    
    if game == "–ó–∞–≥–∞–¥–∫–∏":
        await start_riddle_game(callback_query, state)
    elif game == "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞":
        await start_math_game(callback_query, state)
    elif game == "–£–≥–∞–¥–∞–π":
        await start_word_guess_game(callback_query, state)
        
async def start_riddle_game(callback_query: CallbackQuery, state: FSMContext):
    riddles = [
        ("‚úî –£ –Ω–µ–≥–æ –æ–≥—Ä–æ–º–Ω—ã–π —Ä–æ—Ç, –û–Ω –∑–æ–≤–µ—Ç—Å—è ‚Ä¶", "–±–µ–≥–µ–º–æ—Ç"),
        ("‚úî –ù–µ –ø—Ç–∏—Ü–∞, –∞ —Å –∫—Ä—ã–ª—å—è–º–∏, –ù–µ –ø—á–µ–ª–∞, –∞ –Ω–∞–¥ —Ü–≤–µ—Ç–∫–æ–º", "–±–∞–±–æ—á–∫–∞"),
        ("‚úî –ß—Ç–æ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º, –Ω–æ –¥—Ä—É–≥–∏–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç —ç—Ç–æ —á–∞—â–µ?", "–º–æ—ë –∏–º—è"),
        ("‚úî –ß—Ç–æ –º–æ–∂–Ω–æ –≤–∏–¥–µ—Ç—å —Å –∑–∞–∫—Ä—ã—Ç—ã–º–∏ –≥–ª–∞–∑–∞–º–∏?", "—Å–æ–Ω"),
        ("‚úî –ö–∞–∫ —á–µ–ª–æ–≤–µ–∫ –º–æ–∂–µ—Ç –ø—Ä–æ–≤–µ—Å—Ç–∏ 8 –¥–Ω–µ–π –±–µ–∑ —Å–Ω–∞?", "—Å–ø–∞—Ç—å –Ω–æ—á—å—é"),
        ("‚úî –ù–µ –∂–∏–≤–æ–µ, –∞ –Ω–∞ –≤—Å–µ—Ö —è–∑—ã–∫–∞—Ö –≥–æ–≤–æ—Ä–∏—Ç.", "—ç—Ö–æ"),
        ("‚úî –ß—Ç–æ –Ω–µ –≤–º–µ—Å—Ç–∏—Ç—Å—è –¥–∞–∂–µ –≤ —Å–∞–º—É—é –±–æ–ª—å—à—É—é –∫–∞—Å—Ç—Ä—é–ª—é?", "–µ—ë –∫—Ä—ã—à–∫–∞"),
        ("‚úî –ß–µ–º –∫–æ–Ω—á–∞–µ—Ç—Å—è –ª–µ—Ç–æ –∏ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –æ—Å–µ–Ω—å?", "–±—É–∫–≤–∞ –æ"),
        ("‚úî –í –≥–æ–¥—É 12 –º–µ—Å—è—Ü–µ–≤. –°–µ–º—å –∏–∑ –Ω–∏—Ö –∏–º–µ—é—Ç 31 –¥–µ–Ω—å. –°–∫–æ–ª—å–∫–æ –º–µ—Å—è—Ü–µ–≤ –≤ –≥–æ–¥—É –∏–º–µ—é—Ç 28 –¥–Ω–µ–π?", "–≤—Å–µ"),
        ("‚úî –ö—Ç–æ —Ö–æ–¥–∏—Ç —Å–∏–¥—è?", "—à–∞—Ö–º–∞—Ç–∏—Å—Ç—ã"),
        ("‚úî –•–≤–æ—Å—Ç –ø—É—à–∏—Å—Ç—ã–π, –º–µ—Ö –∑–æ–ª–æ—Ç–∏—Å—Ç—ã–π, –í –ª–µ—Å—É –∂–∏–≤–µ—Ç, –í –¥–µ—Ä–µ–≤–Ω–µ –∫—É—Ä –∫—Ä–∞–¥–µ—Ç", "–ª–∏—Å–∞")    
    ]
    riddle, answer = random.choice(riddles)
    await state.update_data(correct_answer=answer)
    await callback_query.message.edit_text(f"‚úî –û—Ç–≥–∞–¥–∞–π –∑–∞–≥–∞–¥–∫—É:\n\n{riddle}")
    await state.set_state(PetStates.waiting_for_riddle_answer)

async def start_math_game(callback_query: CallbackQuery, state: FSMContext):
    num1, num2 = random.randint(1, 10), random.randint(1, 10)
    operation = random.choice(['+', '-', '*'])
    question = f"{num1} {operation} {num2}"
    answer = eval(question)
    await state.update_data(correct_answer=answer)
    await callback_query.message.edit_text(f"‚úî –†–µ—à–∏ –ø—Ä–∏–º–µ—Ä:\n\n{question} = ?")
    await state.set_state(PetStates.waiting_for_math_answer)

async def start_word_guess_game(callback_query: CallbackQuery, state: FSMContext):
    words = ["–∫–æ—Ç", "—Å–æ–±–∞–∫–∞", "–ø–æ–ø—É–≥–∞–π", "—Ö–æ–º—è–∫", "—á–µ—Ä–µ–ø–∞—Ö–∞"]
    word = random.choice(words)
    await state.update_data(correct_answer=word, attempts=3)
    masked_word = "".join(["_" if i != 0 else w for i, w in enumerate(word)])
    await callback_query.message.edit_text(f"‚úî –£–≥–∞–¥–∞–π —Å–ª–æ–≤–æ:\n\n{masked_word}\n\n–£ —Ç–µ–±—è 3 –ø–æ–ø—ã—Ç–∫–∏.")
    await state.set_state(PetStates.waiting_for_word_guess)

@router.message(PetStates.waiting_for_math_answer)
async def process_math_answer(message: Message, state: FSMContext):
    data = await state.get_data()
    correct_answer = data.get("correct_answer")
    
    try:
        user_answer = int(message.text)
        if user_answer == correct_answer:
            await process_correct_answer(message, state, "–º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫—É—é –∑–∞–¥–∞—á—É")
        else:
            await process_wrong_answer(message, state, f"–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {correct_answer}")
    except ValueError:
        await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")

@router.message(PetStates.waiting_for_word_guess)
async def process_word_guess(message: Message, state: FSMContext):
    data = await state.get_data()
    correct_answer = data.get("correct_answer")
    attempts = data.get("attempts", 3)
    
    if message.text.lower() == correct_answer:
        await process_correct_answer(message, state, "—Å–ª–æ–≤–æ")
    else:
        attempts -= 1
        if attempts > 0:
            masked_word = "".join([w if w in message.text.lower() else "_" for w in correct_answer])
            await message.answer(f"‚ùå –ù–µ–≤–µ—Ä–Ω–æ. –û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: {attempts}\n\n{masked_word}")
            await state.update_data(attempts=attempts)
        else:
            await process_wrong_answer(message, state, f"–ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–ª–æ–≤–æ: {correct_answer}")

def can_play(pet):
    last_played = parse_datetime(pet.get('last_played'))
    return datetime.now() - last_played > timedelta(minutes=10)

async def process_correct_answer(message: Message, state: FSMContext, game_type):
    pet = get_pet(message.from_user.id)
    new_happiness = min(100, pet['happiness'] + 30)
    new_intelligence = min(100, pet['intelligence'] + 20)
    update_pet(message.from_user.id, happiness=new_happiness, intelligence=new_intelligence, last_played=datetime.now().isoformat())
    await message.answer(f"‚úî –ü—Ä–∞–≤–∏–ª—å–Ω–æ! {pet['name']} –æ—á–µ–Ω—å —Ä–∞–¥, —á—Ç–æ –≤—ã —Ä–∞–∑–≥–∞–¥–∞–ª–∏ {game_type} –≤–º–µ—Å—Ç–µ. –£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100.")
    await state.clear()

async def process_wrong_answer(message: Message, state: FSMContext, correct_answer):
    pet = get_pet(message.from_user.id)
    new_happiness = min(100, pet['happiness'] + 10)
    new_intelligence = min(100, pet['intelligence'] - 10)
    update_pet(message.from_user.id, happiness=new_happiness, intelligence=new_intelligence, last_played=datetime.now().isoformat())
    await message.answer(f"‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç. {correct_answer}. –ù–æ {pet['name']} –≤—Å–µ —Ä–∞–≤–Ω–æ –¥–æ–≤–æ–ª–µ–Ω, —á—Ç–æ –≤—ã –∏–≥—Ä–∞–ª–∏ –≤–º–µ—Å—Ç–µ. –£—Ä–æ–≤–µ–Ω—å —Å—á–∞—Å—Ç—å—è —Ç–µ–ø–µ—Ä—å {new_happiness}/100, –∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ {new_intelligence}/100.")
    await state.clear()

@router.message(F.text == "üò¥ –£–ª–æ–∂–∏—Ç—å —Å–ø–∞—Ç—å")
async def pet_sleep(message: Message):
    pet = get_pet(message.from_user.id)
    if pet:
        last_slept = parse_datetime(pet.get('last_slept'))
        if datetime.now() - last_slept > timedelta(minutes=25) or pet.get('energy') < 40:
            sleep_duration = random.randint(2, 7)
            new_energy = min(100, pet['energy'] + sleep_duration * 10)
            new_hunger = min(100, pet['hunger'] + sleep_duration * 5)
            new_happiness = max(0, pet['happiness'] - sleep_duration * 2)
            new_cleanliness = max(0, pet['cleanliness'] - sleep_duration * 3)
            time_asleep = datetime.now() - timedelta(hours=sleep_duration)
            time_asleep_str = time_asleep.isoformat()
            
            update_pet(message.from_user.id, 
                       energy=new_energy, 
                       hunger=new_hunger, 
                       happiness=new_happiness, 
                       cleanliness=new_cleanliness, 
                       last_slept=datetime.now().isoformat(),
                       last_fed=time_asleep_str,
                       last_cleaned=time_asleep_str,
                       last_played=time_asleep_str)
            
            await asyncio.sleep(sleep_duration)
            await message.answer(f"{pet['name']} –ø–æ—Å–ø–∞–ª {sleep_duration} —á–∞—Å–æ–≤ –∏ —Ö–æ—Ä–æ—à–æ –æ—Ç–¥–æ—Ö–Ω—É–ª!\n")
        else:
            await message.answer(f"‚ùå {pet['name']} –µ—â–µ –Ω–µ —É—Å—Ç–∞–ª. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Å–Ω–æ–º.")
    else:
        await message.answer("‚ùå –£ —Ç–µ–±—è –µ—â–µ –Ω–µ—Ç –ø–∏—Ç–æ–º—Ü–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –µ–≥–æ.")